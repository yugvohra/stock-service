package com.arctium.stockservice.security.config;import com.arctium.stockservice.security.entity.UserPrincipal;import io.jsonwebtoken.ExpiredJwtException;import io.jsonwebtoken.MalformedJwtException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.web.authentication.WebAuthenticationDetails;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Optional;import java.util.stream.Collectors;@Componentpublic class JwtRequestFilter extends OncePerRequestFilter {    private static final String AUTHORIZATION = "Authorization";    private static final String BEARER = "Bearer ";    private static final Integer TOKEN_INDEX = 7;    @Autowired    private JwtService jwtService;    private void setSecurityContext(final WebAuthenticationDetails authDetails, final String token) {        final UserPrincipal userPrincipal = jwtService.getUserPrincipalfrom(token);        final UserDetails userDetails = new User(userPrincipal.getUsername(), "",                userPrincipal.getRoles().stream().map(SimpleGrantedAuthority::new)                        .collect(Collectors.toList()));        final UsernamePasswordAuthenticationToken authentication =                new UsernamePasswordAuthenticationToken(userDetails, null,                userDetails.getAuthorities());        authentication.setDetails(authDetails);        SecurityContextHolder.getContext().setAuthentication(authentication);    }    private static Optional<String> getJwtFromRequest(final HttpServletRequest request) {        String bearerToken = request.getHeader(AUTHORIZATION);        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(BEARER)) {            return Optional.of(bearerToken.substring(TOKEN_INDEX));        }        return Optional.empty();    }    /**     * First filter in the request-filter chain     * assess the validity of JWT token, if it is expired or invalid     * Exception is thrown     * @param httpServletRequest     * @param httpServletResponse     * @param filterChain     * @throws ServletException     * @throws IOException     */    @Override    protected void doFilterInternal(final HttpServletRequest httpServletRequest,                                    final HttpServletResponse httpServletResponse, final FilterChain filterChain)            throws ServletException, IOException {        final Optional<String> jwt = getJwtFromRequest(httpServletRequest);        jwt.ifPresent(token -> {            try {                if (jwtService.validateToken(token)) {                    setSecurityContext(new WebAuthenticationDetailsSource()                            .buildDetails(httpServletRequest), token);                }            } catch (IllegalArgumentException | MalformedJwtException | ExpiredJwtException e) {                logger.error("Unable to get JWT Token or JWT Token has expired");            }        });        filterChain.doFilter(httpServletRequest, httpServletResponse);    }}